<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Record & Upload Audio</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, sans-serif; max-width: 760px; margin: 2rem auto; padding: 0 1rem; }
    button { margin: .25rem; padding: .5rem 1rem; }
    input, textarea { width: 100%; box-sizing: border-box; margin: .25rem 0 1rem; padding: .5rem; }
    .small { font-size: 0.9rem; color: #444; }
    pre { background:#f6f8fa; padding: .5rem; overflow:auto; }
  </style>
</head>
<body>
  <h1>Record & Upload Audio</h1>
  <p class="small">Warning: embedding a token client-side is insecure. Use a server-side flow for production.</p>

  <label>GitHub owner (user/org)
    <input id="owner" placeholder="GITHUB_OWNER" value="" />
  </label>

  <label>Repository (hardcoded to "hooks")
    <input id="repo" value="hooks" disabled />
  </label>

  <label>Branch (hardcoded to "main")
    <input id="branch" value="main" disabled />
  </label>

  <label>Commit message
    <input id="message" placeholder="Add recording" value="Add recording via web recorder" />
  </label>

  <label>GitHub Personal Access Token (scopes: repo)
    <input id="token" placeholder="ghp_..." type="password" />
  </label>
  <div style="font-size:0.9rem;margin-bottom:1rem;">
    <button id="saveTokenBtn">Save token to localStorage</button>
    <button id="clearTokenBtn">Clear saved token</button>
  </div>

  <div>
    <button id="startBtn">Start Recording</button>
    <button id="stopBtn" disabled>Stop Recording</button>
    <button id="playBtn" disabled>Play</button>
    <button id="uploadBtn" disabled>Upload to GitHub</button>
  </div>

  <audio id="player" controls style="display:block; margin-top:1rem;"></audio>

  <div style="margin-top:1rem;">
    <strong>Status</strong>
    <pre id="status">Idle</pre>
  </div>

<script>
(function(){
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const playBtn = document.getElementById('playBtn');
  const uploadBtn = document.getElementById('uploadBtn');
  const player = document.getElementById('player');
  const status = document.getElementById('status');

  const tokenInput = document.getElementById('token');
  const saveTokenBtn = document.getElementById('saveTokenBtn');
  const clearTokenBtn = document.getElementById('clearTokenBtn');

  // Load token from localStorage if present
  const LS_KEY = 'gh_token_demo';
  const saved = localStorage.getItem(LS_KEY);
  if (saved) tokenInput.value = saved;

  saveTokenBtn.addEventListener('click', () => {
    const v = tokenInput.value.trim();
    if (!v) { setStatus('Token empty — nothing saved.'); return; }
    localStorage.setItem(LS_KEY, v);
    setStatus('Token saved to localStorage.');
  });

  clearTokenBtn.addEventListener('click', () => {
    localStorage.removeItem(LS_KEY);
    tokenInput.value = '';
    setStatus('Saved token cleared.');
  });

  function setStatus(s){ status.textContent = s; }

  let mediaStream = null;
  let recorder = null;
  let chunks = [];
  let recordedBlob = null;

  startBtn.addEventListener('click', async () => {
    try {
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      recorder = new MediaRecorder(mediaStream);
      chunks = [];
      recorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
      recorder.onstop = () => {
        recordedBlob = new Blob(chunks, { type: 'audio/webm' });
        player.src = URL.createObjectURL(recordedBlob);
        player.style.display = 'block';
        playBtn.disabled = false;
        uploadBtn.disabled = false;
        setStatus('Recording stopped — ready to play/upload.');
      };
      recorder.start();
      startBtn.disabled = true;
      stopBtn.disabled = false;
      setStatus('Recording...');
    } catch (err) {
      setStatus('Error accessing microphone: ' + (err.message || err));
    }
  });

  stopBtn.addEventListener('click', () => {
    if (recorder && recorder.state !== 'inactive') recorder.stop();
    if (mediaStream) {
      mediaStream.getTracks().forEach(t => t.stop());
      mediaStream = null;
    }
    startBtn.disabled = false;
    stopBtn.disabled = true;
  });

  playBtn.addEventListener('click', () => {
    if (player.src) player.play();
  });

  function blobToBase64(blob) {
    return new Promise((res, rej) => {
      const fr = new FileReader();
      fr.onload = () => {
        const dataUrl = fr.result;
        const comma = dataUrl.indexOf(',');
        res(dataUrl.slice(comma + 1));
      };
      fr.onerror = rej;
      fr.readAsDataURL(blob);
    });
  }

  function timestampString() {
    const d = new Date();
    const pad = n => String(n).padStart(2,'0');
    const YYYY = d.getFullYear();
    const MM = pad(d.getMonth() + 1);
    const DD = pad(d.getDate());
    const hh = pad(d.getHours());
    const mm = pad(d.getMinutes());
    const ss = pad(d.getSeconds());
    return `${YYYY}${MM}${DD}-${hh}${mm}${ss}`;
  }

  async function getFileSha(owner, repo, path, branch, token) {
    const url = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/contents/${encodeURIComponent(path)}${branch ? '?ref=' + encodeURIComponent(branch) : ''}`;
    const r = await fetch(url, { headers: { Authorization: 'token ' + token, Accept: 'application/vnd.github.v3+json' }});
    if (r.status === 200) {
      const j = await r.json();
      return j.sha;
    } else if (r.status === 404) {
      return null;
    } else {
      throw new Error('Failed to check file: ' + r.status + ' ' + await r.text());
    }
  }

  uploadBtn.addEventListener('click', async () => {
    const owner = document.getElementById('owner').value.trim();
    const repo = 'hooks'; // hardcoded
    const branch = 'main'; // hardcoded
    const message = document.getElementById('message').value.trim() || 'Add recording';
    const token = document.getElementById('token').value.trim();

    if (!owner || !token) { setStatus('Please fill owner and token.'); return; }
    if (!recordedBlob) { setStatus('No recording available.'); return; }

    try {
      setStatus('Preparing audio...');
      const b64 = await blobToBase64(recordedBlob);

      // Hardcoded folder path
      const folder = 'uploads/recordings';
      const fname = `recording-${timestampString()}.webm`;
      const path = folder + '/' + fname;

      setStatus('Checking existing file (to get SHA if needed)...');
      const sha = await getFileSha(owner, repo, path, branch, token);

      const payload = {
        message: `${message} — ${fname}`,
        content: b64,
      };
      if (branch) payload.branch = branch;
      if (sha) payload.sha = sha;

      setStatus('Uploading to GitHub as ' + path + ' ...');
      const putUrl = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/contents/${encodeURIComponent(path)}`;
      const resp = await fetch(putUrl, {
        method: 'PUT',
        headers: {
          Authorization: 'token ' + token,
          Accept: 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });

      const resultText = await resp.text();
      if (!resp.ok) throw new Error('GitHub API error: ' + resp.status + ' ' + resultText);
      const resultJson = JSON.parse(resultText);
      setStatus('Upload successful. File URL: ' + (resultJson.content && resultJson.content.html_url ? resultJson.content.html_url : '(no html_url returned)'));
    } catch (err) {
      setStatus('Error: ' + (err.message || err));
    }
  });

})();
</script>
</body>
</html>
